import{_ as t,c as s,e as n,o as i}from"./app-BEnvQN0t.js";const a={};function o(r,e){return i(),s("div",null,[...e[0]||(e[0]=[n('<h1 id="writing-an-os-in-nim" tabindex="-1"><a class="header-anchor" href="#writing-an-os-in-nim"><span>Writing an OS in Nim</span></a></h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>I decided to document my journey of writing an OS in Nim. Why Nim? It&#39;s one of the few languages that allow low-level systems programming with deterministic memory management ( garbage collector is optional) with destructors and move semantics. It&#39;s also statically typed, which provides greater type safety. It also supports inline assembly, which is a must for OS development. Other options include C, C++, Rust, and Zig. They&#39;re great languages, but I chose Nim for its simplicity, elegance, and performance.</p><p>Let&#39;s get started!</p><h2 id="fusion-os" tabindex="-1"><a class="header-anchor" href="#fusion-os"><span>Fusion OS</span></a></h2><p>As with any hobby OS project, it needs a name. I decided to call it <strong>Fusion OS</strong>, for no particular reason. I just like the name :-) You can find the source code on GitHub: <a href="https://github.com/khaledh/fusion" target="_blank" rel="noopener noreferrer">https://github.com/khaledh/fusion</a>.</p><p>This is not going to be a Unix-like OS. I&#39;d like to experiment with some ideas that I think would be interesting to explore. Some of these ideas are very challenging, so I&#39;m not sure if I&#39;ll be able to go far with them.</p><p>Here are some of the features I&#39;d like to explore/implement:</p><dl><dt><strong>Single Address Space</strong></dt><dd>This basically means that all processes share a single 64-bit virtual address space. I may still use per-process page tables for memory protection, but the address space will be shared.</dd><dt><strong>Capability-based Security</strong></dt><dd>This is a security model where access to resources is controlled by capabilities, which are unforgeable tokens that grant access to a resource. In addition to typical resources ( e.g. files, devices, etc.), virtual memory regions will also be treated as resources, and access to them will be controlled by capabilities.</dd><dt><strong>Computations as State Machines</strong></dt><dd>Kernel services, interrupt handlers, and user processes will be implemented as single-threaded state machines. Concurrency will be achieved by running multiple state machines in parallel.</dd><dt><strong>Message Passing</strong></dt><dd>State machines will communicate with each other by sending messages (think events/commands), both synchronously and asynchronously.</dd><dt><strong>Memory Mapped Filesystem</strong></dt><dd>The filesystem will be memory mapped into the address space, so that files can be accessed as memory.</dd></dl><p>In the next section, we&#39;ll set up our development environment.</p>',10)])])}const d=t(a,[["render",o],["__file","01-intro.html.vue"]]),c=JSON.parse(`{"path":"/osdev/01-intro.html","title":"Writing an OS in Nim","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"Fusion OS","slug":"fusion-os","link":"#fusion-os","children":[]}],"git":{"updatedTime":1744638230000},"filePathRelative":"osdev/01-intro.md","excerpt":"\\n<h2>Introduction</h2>\\n<p>I decided to document my journey of writing an OS in Nim. Why Nim? It's one of the few\\nlanguages that allow low-level systems programming with deterministic memory management (\\ngarbage collector is optional) with destructors and move semantics. It's also statically\\ntyped, which provides greater type safety. It also supports inline assembly, which is a\\nmust for OS development. Other options include C, C++, Rust, and Zig. They're great\\nlanguages, but I chose Nim for its simplicity, elegance, and performance.</p>"}`);export{d as comp,c as data};

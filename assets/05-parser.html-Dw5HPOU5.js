import{_ as n,c as i,e as r,a as o,d as t,b as a,w as d,r as h,o as c}from"./app-BEnvQN0t.js";const l="/assets/parsing-DgVhCBlr.png",p="/assets/ast-structure-Bw1zoPmL.png",m="/assets/psi-structure-BJf_ugxf.png",u={};function f(g,e){const s=h("RouteLink");return c(),i("div",null,[e[5]||(e[5]=r('<h1 id="parser" tabindex="-1"><a class="header-anchor" href="#parser"><span>Parser</span></a></h1><p>In this section, we will explore the various concepts involved in parsing, including how the parser works, structure of the AST and the PSI, and how they are related. In the next section, we will implement a simple parser by hand, before moving on to generate the parser using Grammar-Kit.</p><h2 id="overview" tabindex="-1"><a class="header-anchor" href="#overview"><span>Overview</span></a></h2><p>In order to work with the language constructs at a higher level, we need to parse the source code. The parser is responsible for converting the stream of tokens provided by the lexer into an abstract syntax tree (AST).</p><p>However, while the AST provides a view into the structure of the source code, it does not provide any semantic information. For example, while the parser can determine that a sequence of tokens is a function call, it cannot determine if the function is defined or if the arguments are valid. This is where the Program Structure Interface (PSI) comes in. The PSI is built on top of the AST, and provides a higher-level API for working with the source code.</p><p>The following diagram shows the relationship between the lexer, parser, AST, and PSI.</p><p style="text-align:center;"><img src="'+l+'" alt="Parsing" width="600"></p><ul><li>The lexer reads the source code as a sequence of characters and produces a stream of tokens.</li><li>The parser (with the help of <code>PsiBuilder</code>) reads the stream of tokens and produces an abstract syntax tree (AST).</li><li>The conversion from AST to PSI is done through the <code>ParserDefinition.createElement()</code> method, which is responsible for creating the appropriate PSI elements for a given AST node.</li></ul><p>I&#39;m not sure why the <code>PsiBuilder</code> is named as such, since it is used in the parsing step which produces AST nodes, not PSI elements. In my opinion, it would make more sense to name it <code>AstBuilder</code> instead ¯\\_(ツ)_/¯.</p><h2 id="ast-structure" tabindex="-1"><a class="header-anchor" href="#ast-structure"><span>AST Structure</span></a></h2><p>Every node in the AST is represented by the <code>ASTNode</code> interface, which holds a reference to an <code>IElementType</code> object that represents the type of the node. There are three types of nodes in the AST, represented by classes that extend <code>IElementType</code>:</p><ul><li>the root node: represents the entire file (an instance of <code>IFileElementType</code>),</li><li>intermediate nodes: represent the production rules in the grammar (instances of <code>NimElementType</code>), and</li><li>leaf nodes: represent the tokens produced by the lexer (instances of <code>NimTokenType</code>).</li></ul>',12)),o("p",null,[e[1]||(e[1]=t("Note that the ",-1)),e[2]||(e[2]=o("code",null,"IFileElementType",-1)),e[3]||(e[3]=t(" node type has nothing to do with the file type discussed in the ",-1)),a(s,{to:"/nimjet/03-filetype.html"},{default:d(()=>[...e[0]||(e[0]=[t("File Type",-1)])]),_:1}),e[4]||(e[4]=t(" section. The former is a node type in the AST, while the latter represents a file type in the IDE (which does not necessarily have to be a language file).",-1))]),e[6]||(e[6]=r('<p>In the following diagram, I try to illustrate these types of nodes, their base classes, and how the AST is created by the parser.</p><p><img src="'+p+'" alt="AST Structure"></p><p>The three boxes labelled with the <code>AST</code> tag represent the three types of nodes described above. They are given placeholder names to indicate that they are instances of classes that extend <code>IElementType</code>, and that the name of those instances depends on the language construct they represent.</p><ul><li><code>$FileElementName$</code> is a singleton that represents the root node type of the AST (e.g. <code>NIM_FILE</code>)</li><li><code>$ElementName$</code> represents an intermediate node (e.g. <code>CASE_STMT</code>)</li><li><code>$TokenName$</code> represents a leaf node (e.g. <code>STRING_LIT</code>)</li></ul><p>But how does the parser actually create the AST? In the diagram, <code>NimParser</code> is the actual parser class (which can be handwritten or generated), which drives the <code>PsiBuilder</code> by <em>marking</em> regions of tokens in the input stream as nodes in the tree. When the parser tries to parse a grammar rule, it tells the <code>PsiBuilder</code> to start a <em>marker</em> (a region of tokens that will be converted into a node in the AST), and then calls the appropriate method to parse the rule. When the rule is successfully parsed, the parser tells the <code>PsiBuilder</code> to set the marker as <em>done</em>, and passes the matched element type to be associated with the node. If the rule is not parsed successfully, the parser either tells the <code>PsiBuilder</code> to <em>rollback</em> the marker, or generate an error node. Creating markers is done recursively, as the parser descends into the grammar rules.</p><p>As nodes are marked by the parser, the <code>PsiBuilder</code> creates <code>ASTNode</code> instances (implemented by <code>TreeElement</code>), to represent the nodes in the AST. Each <code>ASTNode</code> has a reference to the <code>IElementType</code> object that represents the type of the node (the ones mentioned above). The parser returns the final root node of the AST by calling the <code>PsiBuilder.getTreeBuilt()</code> method.</p><p>The final piece of the puzzle is the <code>ParserDefinition</code> class, which provides methods for creating the lexer (<code>createLexer</code>), the parser (<code>createParser</code>), and the element type representing the root node of the AST (<code>getFileNodeType</code>), which is an instance of <code>IFileElementType</code>.</p><p>The <code>ParserDefinition</code> class also provides a few methods for returning <code>TokenSet</code> objects (not shown in the diagram) that identify certain types of tokens: comments, whitespace, and string literals.</p><ul><li><code>getWhitespaceTokens()</code>: returns a <code>TokenSet</code> of whitespace tokens. These tokens are typically ignored by the parser.</li><li><code>getCommentTokens()</code>: returns a <code>TokenSet</code> of comment tokens. These tokens are also typically ignored by the parser. They are also used to search for <code>TODO</code> patterns in comments.</li><li><code>getStringLiteralElements()</code>: returns a <code>TokenSet</code> of string literal tokens. These tokens are used by the &quot;Search in strings&quot; option during refactoring.</li></ul><h2 id="psi-structure" tabindex="-1"><a class="header-anchor" href="#psi-structure"><span>PSI Structure</span></a></h2><p>As mentioned earlier, the PSI is built on top of the AST, and provides a higher-level API for working with the source code. You can think of the PSI as an enriched view of the AST, with capabilities to navigate, search, and modify the source code. The following diagram shows the different classes and interfaces that make up the PSI, and their relationship to the AST and the <code>ParserDefinition</code>.</p><p style="text-align:center;"><img src="'+m+'" alt="PSI Structure" width="700"></p><p>The bridge between the AST and the PSI is the <code>ASTWrapperPsiElement</code> class, which is a wrapper around an <code>ASTNode</code> that implements the <code>PsiElement</code> interface. The AST is converted to a PSI tree through the <code>ParserDefinition.createElement()</code> method, which creates the appropriate PSI element for a given AST node.</p><p>The entire file is represented by an instance of the <code>PsiFile</code> interface, which also extends <code>PsiElement</code>. This interface is the typical entry point for working with the PSI tree. In our case, the <code>NimFile</code> class implements <code>PsiFile</code>, and is created through the <code>ParserDefinition.createFile()</code> method.</p><p>The PSI tree is then used by the IDE to provide code completion, navigation, refactoring, and other features.</p><p>Now that we have an idea of how the various components of the parser work together, in the next section we will implement a very simpler parser by hand for a simple statement to get a deeper understanding of the process. Later, we will use Grammar-Kit to generate the parser for us from a BNF grammar, since writing a full parser for Nim by hand would be tedious and error-prone.</p>',16))])}const w=n(u,[["render",f],["__file","05-parser.html.vue"]]),S=JSON.parse('{"path":"/nimjet/05-parser.html","title":"Parser","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Overview","slug":"overview","link":"#overview","children":[]},{"level":2,"title":"AST Structure","slug":"ast-structure","link":"#ast-structure","children":[]},{"level":2,"title":"PSI Structure","slug":"psi-structure","link":"#psi-structure","children":[]}],"git":{"updatedTime":1725853500000},"filePathRelative":"nimjet/05-parser.md","excerpt":"\\n<p>In this section, we will explore the various concepts involved in parsing, including how\\nthe parser works, structure of the AST and the PSI, and how they are related. In the next\\nsection, we will implement a simple parser by hand, before moving on to generate the\\nparser using Grammar-Kit.</p>\\n<h2>Overview</h2>"}');export{w as comp,S as data};
